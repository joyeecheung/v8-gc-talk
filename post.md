# 解读 V8 垃圾回收日志：以一个 Node.js 内存泄漏为例

## 前言

这篇文章来自于我在 Node 基金会主办的 Node Live Beijing 的分享，之前看 Node Live Paris 的视频说的也是英文，所以我准备的也是英文，结果发现现场微软为基金会的人准备了一个翻译，看大家都说的中文于是我也临时改成中文了，说的时候有些地方还没转过弯来磕磕巴巴的。加上分享时长有限很多地方没有展开，于是现在事后来用文字再详细写一下这个题目。

## 背景

国内的 Node.js 开发者应该不少都知道，阿里是国内的大公司里使用 Node.js 较多的一家，目前大部分的场景是在阿里内部的一系列分布式系统/服务/中间件之上，使用 Node.js 来开发原来使用 PHP/Java 开发的应用层的程序。应用层主要与各种数据源和底层系统使用基于 HTTP 或者 RPC 的 API 交流，加上一定的业务逻辑，渲染 HTML 或者拼装 JSON，通过负载均衡服务等设施与前端/客户端沟通。这里主要的瓶颈是 I/O，并且需求变化频繁，跟大量使用 JavaScript 的前端/客户端团队联系紧密，如果继续使用开发底层系统的静态语言（C++/Java 等），测试、部署、开发环境冷启动速度都慢一些，而且和前端团队多一层代沟，这个场景下使用 Node.js 来开发应用层的好处是显而易见的。这种架构离不开阿里内部一系列成熟的底层系统，这些静态语言开发的系统在 ACID、分布式和计算密集等场景下很好地弥补了 Node.js 的短板，与语言灵活、开发速度快的 Node.js 在一起，形成了一个多语言（polyglot）的生态系统，各取所长。除了国内的阿里，国外的 Paypal、Netflix 等体量比较大的公司也是出于类似的考虑使用 Node.js 来做类似的事情（有趣的是，这些公司不少也是 Java 起家的，而且大多也像阿里一样，有比较成熟的底层系统）。

虽然选中 Node.js 开发应用看中的是它的灵活和开发效率，但是用于开发一个企业的线上系统，监控、日志、性能调优等一系列配套是一定要跟上的，测试也是必不可少的。在 Node.js 推广的过程中，不少架构师质疑 Node.js （或者说，使用 Node.js 开发的工程师们）在这方面的短板，认为它难堪重任。特别是由于 JavaScript 在后端的历史较短，大部分 JavaScript 的相关工具针对的并不是后端这种长时间运行的场景，Node.js 在这方面性能调优和分析的手段有限（比如，“Node.js 应用出现了内存泄漏怎么办？”）。一个典型现象是，Java 程序员们大多对 JVM 和 GC 都有一定的了解，面试中也经常会出现相关的问题，而 JavaScript 的程序员们大部分来自前端背景，写的程序并不在长时间运行的后端场景下，因此相对而言在这方面的了解较少，Node.js 开发的面试中也较少会问 V8 相关的问题。

在这种背景下，诞生了 alinode。我们是从为阿里内部提供 Node.js 相关性能服务起家的，产品是一个改造过的 Node.js 运行时（和 LTS 保持兼容），用于提供一系列企业级应用需要的性能管理支持，以及一个配套的 SaaS 平台，提供性能监控管理、分析优化、安全漏洞提示以及一系列 Node.js 周边服务。在搬家到阿里云之后，也开始对外部客户提供服务。

## 为什么要了解 V8 的垃圾回收日志？

在后端的长时间运行场景下，对虚拟机有垃圾回收（Garbage Collection，下称 GC）的语言，GC 是一个需要重点关注的方面，它不仅影响内存使用的增长，也会在运行不畅的时候影响 CPU 的利用，进而影响程序的可用性和响应速度。JavaScript 作为一个来自客户端场景的语言，在 GC 方面的调优工具存在一定的短板。JavaScript 调优必备的 Chrome Devtools 针对前端场景，提供了 CPU Profile、Heap Snapshot 和 Heap Timeline 三种工具，却没有将 GC 日志直接暴露出来的功能，也没有相应的分析功能，相关的文档更是缺乏，日志的格式、字段的意义都免不了要阅读 V8 的源代码才能理解。这篇文章的目的之一，也是补足这方面的空白。

那么，GC 日志的主要使用场景有哪些呢？

* 由于 V8 在做 GC 时，代码的执行会有一定的停顿（在 V8 引入并行 GC 前更为严重），如果代码中出现了对象的频繁分配与回收，那么程序将会花费不少时间在 GC 的停顿上，影响应用的响应速度。GC 日志能够展现出 GC 停顿发生的时间、时长与模式，并且指明是哪类对象的 GC 导致了停顿、在 GC 的哪一步中耗时最长，帮助你确定应用的性能问题是否与 GC 有关，如果有，那么还能帮助你追溯到问题的来源。
* 当代码中存在内存泄漏时，GC 日志会有较为明显的特征。一条内存使用的折线只能告诉你发生了内存泄漏，而 GC 日志中多维度的信息能够告诉你堆上的哪个空间发生了泄漏，泄漏的模式如何，有什么规律。线下修复泄漏后再将新代码上线，重新做一次 GC 日志，对比一新代码下 GC 的模式以及各空间的变化规律，也能帮助你确定新的代码修复了泄漏，而不是治标不治本，埋藏了一个定时炸弹
* 虽然 Heap Snapshot 和 Heap Timeline 能为你指出具体什么对象（甚至哪段代码）出现了内存泄漏，但在一个较为复杂的应用里，直接看这两个数据容易被细节淹没，迷失在微观的视图里。GC 日志能够帮助你形成一个宏观的印象，定位出问题代码的方位，并且能起到排除的作用。抓内存泄漏就像破案，只有犯罪现场的指纹和DNA，但案犯没有前科，数据不在系统里，没有其他线索来找到嫌疑人来比对，那么破案依然是十分困难的。如果工程师不认识堆上的可疑对象（比如泄漏的函数或者对象的构造函数没有命名，像`asyncOperation(function(err, data) {})`里头的回调或`var Class = function(){}`这样的构造函数，或者对象构造函数命名重复太多导致无法对应到位置），只看堆上的数据，也会一头雾水。正如警探们需要从作案动机、作案时间、现场位置、作案工具等线索入手，排除有不在场证明的嫌疑人，逐步定位目标，再用指纹和DNA证明某个嫌疑人就是案犯一样，我们也需要一切能获取到的线索，才能排除噪音，逐步缩小目标范围，定位到罪魁祸首。

## V8 GC 简介

为了保证我们在一个起跑线，这里先介绍一下什么是 GC。

### 什么是 GC

Garbage Collection 是在内存中回收垃圾（Garbage）的过程，所谓的垃圾，就是内存中不会再被使用的部分。在 C/C++ 等语言里，我们需要手动分配（`malloc`/`free`）和释放（`new`/`delete`）内存，虽然人工调优的代码能够实现细粒度的控制，充分榨干资源，但人工的介入也意味着失误率的提高，如果出现了管理不当，便会发生过引用错误（过早释放）和内存泄漏（忘记或太晚释放）等各种问题。有时判断何时应该释放内存需要全局的知识，而释放的决定需要在局部作出，[本身就是一个困难的问题](http://yanniss.github.io/117-15/gcsurvey.pdf)。同时，手工管理内存通常免不了要在 API 中体现一定的约束，增加了模块之间的耦合度。这些都给开发者增加了思维负担。

JavaScript、Java 等语言在语言的运行时中内置了垃圾回收的机制，使得开发者在编写代码时不需要关心内存管理，运行时能够自动分析出不会再被使用的内存并加以回收利用——垃圾回收器作为一个能够获取全局信息的存在，更适合解决何时释放内存这个经常为全局性的问题。虽然开发者失去了一定程度上的控制和优化能力，但得到了更高的开发效率，更低的耦合度和一定程度上的内存安全保证，对于许多偏应用的开发来说是一个合适的权衡选择。

### V8 的 GC 概述

JavaScript的标准ECMAScript里没有对GC做相关的要求，因此JavaScript的GC完全由引擎决定。这篇文章里的内容基于 V8 4.5.103.35（即当前的 LTS Node.js 4.x 使用的版本）。Node.js 下一个 LTS 升级到了 V8 5.x，其中的 GC 引入了一系列改进（主要是并行 GC 方面的改进，这些改造统称为 orinoco，参见 V8 的博客），但 GC 日志大体格式还是与之前差不多，整体的 GC 策略也与原来类似，这篇文章的大部分内容应该还是适用的。

### 弱分代假设（The Weak Generational Hypothesis）

在 GC 的研究中有一个广为人知的现象，叫做弱分代假设（The Weak Generational Hypothesis），许多 GC 的研究者／开发者们观察到：

1. 大多数对象死的早
2. 那些死得不早的对象，通常倾向于永生

基于这个现象，许多垃圾回收器将对象进行分代，对生存周期长度不同的对象采用不同的垃圾回收算法。那些新分配的对象会得到更多的“关照”，检查它们是否已经无人引用可以回收。而那些多次检查后依然顽强生存下来的对象会被晋升到下一代，之后被检查的频率也会越来越低。这样，垃圾回收器可以尽快地回收掉大量短命的对象，节省了内存，又避免了频繁检查那些按照弱分代假设倾向于永生的老对象，节省了时间。

V8 的垃圾回收器也是基于弱分代假设将对象进行分代回收的一员，它将 JavaScript 对象分成了两代：新生代（new generation）和老生代（old generation），新生代使用拿空间换时间的 Scavenger 算法，快速回收内存，老生代使用 Mark-Sweep 算法，在空间和时间中取得平衡，并辅以 Mark-Compact 算法解决 Mark-Sweep 造成的内存碎片问题。

## 相关链接

* Netflix
* Paypal
* alinode 的 GC 日志分析工具提供的功能一部分灵感来自于  （HotSpot JVM Performance Lead）在 SE-Radio 分享的 Java GC 日志分析技巧。
